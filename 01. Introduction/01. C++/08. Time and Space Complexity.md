# Time and Space Complexity

Most of the time there are multiple ways of solving a problem with different algorithms. When comparing them, we usually think about how much time and resources might an algorithm taken when implemented.

To measure the performance of an algorithm, we use time and space complexity analysis.

## Time Complexity

The time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the input.

Let's see how time complexity get plotted between an old computer and a new computer,
![example 1](assets/time%20complexity%20example%201.png)

So in here the `gradient` (rate of increase) is called the **Time Complexity**.

Since the **time complexity** is not measured by time (seconds, minutes), we use **Big-Oh Notation**.

Example:

![example](assets/big-oh%20example.png)

---

Let's take a simple for loop,

```cpp

for(int i=0; i<5; i++)
{
    cout << "abbys";
}
```

So in here each iteration has 3 setps,

1. check (i<5)
2. print (cout)
3. increment (i++)

So the total of steps is equal to the `prime big-oh notation`. But this is not effective when comes to large operations. Therefore, we have ground rules,

1. **Always compute on worst case scenario.**
2. **Avoid constants.**
3. **Avoid lower values.**

---

Example:

```cpp
for(int i=0; i<N; i++)
{
    for(int j=0; j<N; j++){
        .
        .
        .
    }
}
```

![example](assets/flow%20example.png)

So, `i` runs for `N` and `j` runs for `N`. Therefore, the time complexity will be **$O(N^2)$**.

---

Example:

```cpp
for(int i=0; i<N; i++)
{
    for(int j=0, j<i, j++)
    {
        //code
    }
}
```

![example 2](assets/time%20complexity%20example%202.png)

## Space Complexity

- It's the **memory space** that the program takes.
- Since we want a machine independent result, we will use **Big-oh Notation** for this as well.

![info](assets/space%20complexity%20info.png)

`demo.cpp`

```cpp
#include <iostream>
using namespace std;

int main()
{
    int a, b;
    cin >> a >> b;
    int c = a + b;
    cout << c;
}
```

So in here variables `a` and `b` are considered as **input space**. And the variable `c` is cosidered as **auxiliary space** since it is an extra variable use for the algorithm.

So in this case, the memeory doesn't get change. So its **O(1)**.

Another example:

```cpp
int main()
{
    int[N] numbers;
}

```

In this case, since the memory size can change. Therefore. the big-oh notation is **O(N)**.
